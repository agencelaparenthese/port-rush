<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Port Rush â€“ Export Runner (Simple)</title>
  <style>
    :root{ font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body{ margin:0; background:#0b0f14; color:#e6edf3; display:flex; min-height:100vh; }
    .wrap{ margin:auto; width:min(980px, 96vw); }
    canvas{
      width:100%;
      aspect-ratio: 16/9;
      border:1px solid #243244;
      border-radius:18px;
      touch-action:none;
      display:block;
      background:#000;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .hud{ display:flex; gap:10px; flex-wrap:wrap; justify-content:space-between; align-items:center; margin:10px 0; }
    .pill{ background:#121a24; border:1px solid #243244; padding:8px 10px; border-radius:12px; font-size:14px; }
    b{ font-weight:800; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <div class="pill">Personnage: <b id="laureate">â€”</b></div>
      <div class="pill">Score: <b id="score">0</b></div>
      <div class="pill">Temps: <b id="time">0:30</b></div>
    </div>
    <div class="pill">Ordi: <b>Espace</b>/<b>â†‘</b> | Mobile: <b>Tap</b></div>
  </div>

  <canvas id="c" width="960" height="540"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  const scoreEl = document.getElementById("score");
  const timeEl  = document.getElementById("time");
  const laureateEl = document.getElementById("laureate");

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const px = (n)=>Math.round(n);

  // ===== Specs
  const GAME_DURATION = 30;
  const SAFE_START = 0.20;
  const GRAV = 2500;
  const JUMP_V = -900;

  const BASE_SPEED = 420;
  const MAX_SPEED  = 680;

  const groundY = H - 120;      // quai/route
  const waterY  = groundY + 46; // mer
  const DEATH_Y = waterY + 34;

  // ===== Characters (stylisÃ©s)
  const CHAR = [
    { name:"Douanier", type:"customs" },
    { name:"Responsable export", type:"export" },
    { name:"Olivier", type:"olivier" },
  ];
  let selected = 0;

  // ===== State
  const State = { PICK:"pick", RUN:"run", OVER:"over", WIN:"win" };
  let state = State.PICK;

  // ===== Player
  const player = {
    sx: 220, y: groundY - 64,
    w: 34, h: 64,
    vy: 0,
    onGround: true,
    jumpBuffer: 0,
    coyote: 0,
    slip: 0,
    slipDir: 0
  };

  // ===== World
  let camX = 0;
  let elapsed = 0;
  let score = 0;
  let tPrev = 0;

  let blocks = [];
  let gaps = [];
  let hazards = [];
  let nextX = 0;

  // Trophy
  let winT = 0;

  // ===== Palette
  const CONTAINER = ["#ef4444","#f97316","#f59e0b","#22c55e","#14b8a6","#3b82f6","#6366f1","#a855f7","#ec4899","#eab308"];
  const pick = (arr)=>arr[(Math.random()*arr.length)|0];
  const vivid = ()=>pick(CONTAINER);

  // ===== HUD
  function updateHUD(){
    scoreEl.textContent = String(score);
    const remaining = Math.max(0, Math.ceil(GAME_DURATION - elapsed));
    timeEl.textContent = `0:${String(remaining).padStart(2,"0")}`;
    laureateEl.textContent = CHAR[selected].name;
  }
  updateHUD();

  function speedNow(){
    const t = clamp(elapsed / GAME_DURATION, 0, 1);
    return BASE_SPEED + (MAX_SPEED - BASE_SPEED) * (t*t*0.92);
  }

  // ===== Input
  function requestJump(){
    if (state === State.RUN) player.jumpBuffer = 0.14;
  }

  addEventListener("keydown", (e)=>{
    if (e.code==="Space" || e.code==="ArrowUp") { e.preventDefault(); requestJump(); }

    if (state===State.PICK && (e.code==="Enter" || e.code==="Space")) { e.preventDefault(); startRun(); }
    if ((state===State.OVER || state===State.WIN) && (e.code==="Enter" || e.code==="Space")) { e.preventDefault(); startRun(); }

    if ((state===State.RUN || state===State.OVER || state===State.WIN) && (e.key==="c" || e.key==="C")) {
      state = State.PICK;
    }

    if (state===State.PICK && (e.code==="ArrowLeft" || e.code==="ArrowRight")) {
      selected = (selected + (e.code==="ArrowRight"?1:2))%3;
      updateHUD();
    }
  }, {passive:false});

  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    if (state===State.RUN) requestJump();
    else if (state===State.PICK) handlePickTap(e);
    else startRun();
  }, {passive:false});

  function getCanvasPos(ev){
    const r = canvas.getBoundingClientRect();
    return {
      x: (ev.clientX - r.left) * (W / r.width),
      y: (ev.clientY - r.top)  * (H / r.height)
    };
  }

  // ===== Start
  function startRun(){
    state = State.RUN;
    elapsed = 0;
    score = 0;
    camX = 0;
    winT = 0;

    player.y = groundY - player.h;
    player.vy = 0;
    player.onGround = true;
    player.jumpBuffer = 0;
    player.coyote = 0;
    player.slip = 0;
    player.slipDir = 0;
    player.sx = 220;

    blocks = [];
    gaps = [];
    hazards = [];
    nextX = 420;

    updateHUD();
  }

  // ===== Collision
  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // ===== World generation
  function ensureWorld(){
    while (nextX < camX + W + 1200) addSegment();
    const cut = camX - 500;
    blocks = blocks.filter(b => b.x + b.w > cut);
    gaps = gaps.filter(g => g.x + g.w > cut);
    hazards = hazards.filter(h => h.x + h.w > cut && h.y < H + 600);
  }

  function addSegment(){
    if (elapsed < SAFE_START) { nextX += 140; return; }

    const minSpacing = MAX_SPEED * 0.72;

    const ox = nextX + rand(120, 220);
    const ow = rand(160, 240);
    const oh = rand(60, 104);
    const oy = groundY - oh;
    blocks.push({ x: ox, y: oy, w: ow, h: oh, color: vivid() });

    if (Math.random() < 0.42) {
      const sx = ox + rand(40, 120);
      const sw = rand(120, 190);
      const sh = rand(60, 96);
      const sy = oy - rand(40, 78);
      blocks.push({ x: sx, y: sy, w: sw, h: sh, color: vivid() });
    }

    const hx = ox + ow + rand(180, 260);
    const r = Math.random();

    if (r < 0.34) {
      hazards.push({ kind:"forklift", x:hx, y:groundY-46, w:96, h:46, vx:-rand(34, 70) });
      if (Math.random() < 0.35) {
        hazards.push({ kind:"forklift", x:hx + rand(160, 240), y:groundY-46, w:96, h:46, vx:-rand(28, 60) });
      }
    } else if (r < 0.54) {
      hazards.push({
        kind:"hook",
        x: hx + rand(40, 140),
        w: 18, h: 48,
        yTop: groundY - 270,
        minY: groundY - 220,
        maxY: groundY - 68,
        phase: rand(0, Math.PI*2),
        phaseSpeed: rand(1.9, 2.8),
        y: groundY - 220
      });
    } else if (r < 0.72) {
      hazards.push({ kind:"oil", x:hx + rand(0, 130), y:groundY-10, w:100, h:10 });
    }

    if (Math.random() < 0.34) {
      const gapX = hx + rand(190, 280);
      const gapW = rand(110, 170);
      gaps.push({ x: gapX, w: gapW });
      nextX = gapX + gapW + rand(220, 320) + minSpacing;
      return;
    }

    nextX = ox + ow + minSpacing + rand(200, 320);
  }

  // ===== Update
  function update(dt){
    elapsed += dt;
    camX += speedNow() * dt;
    ensureWorld();

    // hazards animation
    for (const h of hazards){
      if (h.kind === "forklift") h.x += h.vx * dt;
      if (h.kind === "hook") {
        h.phase += h.phaseSpeed * dt;
        const s = (Math.sin(h.phase) + 1)/2;
        h.y = h.minY + (h.maxY - h.minY)*s;
      }
    }

    // slip
    player.slip = Math.max(0, player.slip - dt);
    if (player.slip > 0) {
      if (!player.slipDir) player.slipDir = Math.random()<0.5 ? -1 : 1;
      player.sx += player.slipDir * 30 * dt;
      player.sx = clamp(player.sx, 150, 290);
    } else {
      player.slipDir = 0;
      player.sx += (220 - player.sx) * Math.min(1, dt*6);
    }

    score += Math.floor((speedNow() * dt) * 0.12);
    updateHUD();

    // physics
    player.vy += GRAV * dt;
    player.jumpBuffer = Math.max(0, player.jumpBuffer - dt);
    player.coyote = Math.max(0, player.coyote - dt);

    if (player.jumpBuffer > 0 && (player.onGround || player.coyote > 0)) {
      player.vy = (player.slip > 0) ? (JUMP_V * 0.92) : JUMP_V;
      player.onGround = false;
      player.coyote = 0;
      player.jumpBuffer = 0;
    }

    const prevY = player.y;
    player.y += player.vy * dt;

    const pxWorld = camX + player.sx;
    const pr = { x:pxWorld, y:player.y, w:player.w, h:player.h };

    // containers: top safe, side death
    player.onGround = false;
    for (const b of blocks){
      if (!aabb(pr.x, pr.y, pr.w, pr.h, b.x, b.y, b.w, b.h)) continue;

      const wasAbove = (prevY + player.h) <= (b.y + 6);
      if (player.vy >= 0 && wasAbove) {
        player.y = b.y - player.h;
        player.vy = 0;
        player.onGround = true;
        player.coyote = 0.10;
        pr.y = player.y;
      } else {
        state = State.OVER;
        return;
      }
    }

    // ground ONLY if not over a gap
    if (player.y + player.h >= groundY) {
      const footX = pxWorld + player.w*0.5;
      const overGap = gaps.some(g => footX >= g.x && footX <= g.x + g.w);
      if (!overGap) {
        player.y = groundY - player.h;
        player.vy = 0;
        player.onGround = true;
        player.coyote = 0.10;
      }
    }

    // guaranteed death line
    if (player.y + player.h > DEATH_Y) {
      state = State.OVER;
      return;
    }

    // hazards
    for (const h of hazards){
      if (h.kind === "oil") {
        const oilRect = { x:h.x, y:h.y-6, w:h.w, h:h.h+10 };
        if (player.onGround && aabb(pr.x, pr.y, pr.w, pr.h, oilRect.x, oilRect.y, oilRect.w, oilRect.h)) {
          player.slip = 0.8;
        }
      } else {
        if (aabb(pr.x, pr.y, pr.w, pr.h, h.x, h.y, h.w, h.h)) {
          state = State.OVER;
          return;
        }
      }
    }

    if (elapsed >= GAME_DURATION) {
      state = State.WIN;
      return;
    }
  }

  // ===== Drawing helpers
  function fillRect(x,y,w,h,c,a=1){
    ctx.globalAlpha = a;
    ctx.fillStyle = c;
    ctx.fillRect(px(x), px(y), px(w), px(h));
    ctx.globalAlpha = 1;
  }

  function drawSky(){
    fillRect(0,0,W,H,"#93c5fd",1);
    fillRect(0,0,W,H*0.55,"#60a5fa",0.55);

    fillRect(740, 54, 56, 56, "#fde68a", 0.96);
    fillRect(750, 64, 36, 36, "#fef3c7", 0.90);

    const p = (camX*0.10) % 260;
    for (let i=0;i<7;i++){
      const x = -p + i*260 + 60;
      const y = 70 + (i%3)*22;
      fillRect(x, y, 60, 14, "#ffffff", 0.88);
      fillRect(x+18, y-10, 54, 16, "#ffffff", 0.88);
      fillRect(x+42, y+2, 60, 14, "#ffffff", 0.88);
    }
  }

  // SIMPLE SEA: no cargos
  function drawSea(){
    fillRect(0, waterY, W, H-waterY, "#0b2a4a", 1);
    fillRect(0, waterY, W, 26, "#164e63", 0.55);
    const wob = (camX*0.20) % 18;
    for (let i=0;i<10;i++){
      const y = waterY + 14 + i*14;
      fillRect(-wob, y, W+40, 2, "#bfdbfe", 0.10);
    }
  }

  function drawCranes(){
    const pc = (camX*0.18) % 520;
    for (let i=0;i<4;i++){
      const x = -pc + i*520 + 140;
      const baseY = groundY - 220;
      fillRect(x, baseY+40, 16, 170, "#1f2937", 0.7);
      fillRect(x-150, baseY+52, 260, 10, "#1f2937", 0.7);
      fillRect(x-164, baseY+46, 22, 18, "#1f2937", 0.7);
      fillRect(x+84, baseY+62, 3, 120, "#111827", 0.55);
      fillRect(x+76, baseY+180, 18, 12, "#111827", 0.6);
    }
  }

  // SIMPLE ROAD: no "under-structure"
  function drawRoad(){
    fillRect(0, groundY, W, waterY-groundY, "#6b7280", 1);
    fillRect(0, groundY, W, 6, "#334155", 1);

    for (let x=0;x<W;x+=34){
      fillRect(x, groundY+22, 18, 4, "#e5e7eb", 0.35);
    }
    for (let x=0;x<W;x+=24){
      fillRect(x, groundY+40, 16, 6, (Math.floor(x/24)%2===0) ? "#f59e0b" : "#111827", 0.35);
    }
  }

  function drawContainer(x,y,w,h,color){
    fillRect(x,y,w,h,color,0.98);
    for (let i=1;i<=6;i++){
      const rx = x + i*(w/7) - 2;
      fillRect(rx, y+8, 3, h-16, "#000", 0.18);
    }
    fillRect(x+10, y+8, w-20, 3, "#ffffff", 0.14);
    fillRect(x, y, w, 2, "#0b0f14", 0.35);
    fillRect(x, y+h-2, w, 2, "#0b0f14", 0.35);
    fillRect(x, y, 2, h, "#0b0f14", 0.35);
    fillRect(x+w-2, y, 2, h, "#0b0f14", 0.35);
  }

  function drawGaps(){
    for (const g of gaps){
      const sx = g.x - camX;
      if (sx + g.w < -260 || sx > W+260) continue;
      fillRect(sx, groundY, g.w, H-groundY, "#0b2a4a", 1);
      for (let i=0;i<6;i++){
        fillRect(sx, groundY+10+i*12, g.w, 2, "#bfdbfe", 0.10);
      }
    }
  }

  function drawBlocks(){
    for (const b of blocks){
      const sx = b.x - camX;
      if (sx + b.w < -260 || sx > W+260) continue;
      drawContainer(sx, b.y, b.w, b.h, b.color);
    }
  }

  function drawHazards(){
    for (const h of hazards){
      const sx = h.x - camX;
      if (sx + h.w < -260 || sx > W+260) continue;

      if (h.kind === "forklift"){
        fillRect(sx, h.y+10, h.w, h.h-10, "#f97316", 0.98);
        fillRect(sx+h.w-18, h.y-12, 8, h.h+12, "#111827", 0.95);
        fillRect(sx+h.w-30, h.y+h.h-8, 22, 5, "#111827", 0.95);
        fillRect(sx+10, h.y+h.h-6, 14, 12, "#0b0f14", 1);
        fillRect(sx+h.w-26, h.y+h.h-6, 14, 12, "#0b0f14", 1);
      } else if (h.kind === "oil"){
        fillRect(sx, h.y, h.w, h.h, "#111827", 0.95);
        fillRect(sx+10, h.y+2, h.w-20, 3, "#60a5fa", 0.35);
        fillRect(sx+18, h.y+6, h.w-36, 2, "#93c5fd", 0.20);
      } else if (h.kind === "hook"){
        fillRect(sx + Math.floor(h.w/2)-1, h.yTop, 2, (h.y - h.yTop), "#111827", 0.70);
        fillRect(sx, h.y, h.w, h.h, "#111827", 0.98);
        fillRect(sx+3, h.y+6, h.w-6, 4, "#e5e7eb", 0.25);
        fillRect(sx-6, h.y+h.h-6, 12, 6, "#111827", 0.98);
      }
    }
  }

  function drawCharacter(x,y,type){
    const w = player.w, h = player.h;
    fillRect(x+6, groundY+10, w-12, 8, "#000", 0.22);

    if (type === "customs") {
      fillRect(x+4, y+h-10, 12, 12, "#0b0f14", 1);
      fillRect(x+w-16, y+h-10, 12, 12, "#0b0f14", 1);
      fillRect(x+4, y+34, w-8, 22, "#111827", 1);
      fillRect(x+2, y+22, w-4, 20, "#d9f99d", 1);
      fillRect(x+4, y+26, w-8, 3, "#1f2937", 0.55);
      fillRect(x+4, y+34, w-8, 3, "#1f2937", 0.55);
      fillRect(x, y+22, 6, 22, "#0f172a", 1);
      fillRect(x+w-6, y+22, 6, 22, "#0f172a", 1);
      fillRect(x+6, y+10, w-12, 14, "#111827", 1);
      fillRect(x+4, y+2, w-8, 10, "#0f172a", 1);
      fillRect(x+2, y+10, w-4, 3, "#0f172a", 1);
      fillRect(x+6, y+6, w-12, 2, "#e5e7eb", 0.25);
      fillRect(x+w-12, y+24, 6, 6, "#0ea5e9", 0.9);
    }

    if (type === "export") {
      fillRect(x+4, y+h-10, 12, 12, "#0b0f14", 1);
      fillRect(x+w-16, y+h-10, 12, 12, "#0b0f14", 1);
      fillRect(x+2, y+20, w-4, 38, "#1d4ed8", 0.98);
      fillRect(x+9, y+26, w-18, 14, "#e5e7eb", 0.92);
      fillRect(x+w/2-3, y+26, 6, 26, "#7f1d1d", 0.95);
      fillRect(x+6, y+8, w-12, 16, "#111827", 1);
      fillRect(x+7, y+9, w-14, 4, "#0b0f14", 0.80);
      fillRect(x, y+34, 6, 10, "#0f172a", 1);
      fillRect(x+w-6, y+34, 6, 10, "#0f172a", 1);
    }

    if (type === "olivier") {
      fillRect(x+4, y+h-10, 12, 12, "#0b0f14", 1);
      fillRect(x+w-16, y+h-10, 12, 12, "#0b0f14", 1);
      fillRect(x+2, y+20, w-4, 38, "#334155", 0.98);
      fillRect(x+9, y+26, w-18, 14, "#e5e7eb", 0.92);
      fillRect(x+w/2-3, y+26, 6, 26, "#db2777", 0.95);
      fillRect(x+6, y+10, w-12, 16, "#111827", 1);
      fillRect(x+6, y+6, w-12, 6, "#e5e7eb", 0.92);
      fillRect(x+5, y+10, 2, 10, "#e5e7eb", 0.80);
      fillRect(x+w-7, y+10, 2, 10, "#e5e7eb", 0.80);
      fillRect(x+w/2-4, y+20, 8, 2, "#0b0f14", 0.35);
    }
  }

  function drawRunner(){
    drawCharacter(player.sx, player.y, CHAR[selected].type);
  }

  function drawBottomText(){
    const msg = "Evite les conteneurs, les trous, les flaques, les crochets de grues et les chariots pour gagner le trophÃ©e ! C pour changer dâ€™entreprise.";
    fillRect(0, H-44, W, 44, "#000", 0.40);
    ctx.fillStyle = "#ffffff";
    ctx.font = "800 12px system-ui";
    ctx.textAlign = "center";
    ctx.fillText(msg, W/2, H-18);
  }

  // ===== Pick screen
  function getPickCards(){
    const cardW = 240, cardH = 200, gap = 26;
    const total = cardW*3 + gap*2;
    const sx = (W-total)/2;
    const y = H*0.34;
    return [0,1,2].map(i=>({x:sx+i*(cardW+gap), y, w:cardW, h:cardH}));
  }
  function getStartBtn(){ return {x:W/2-130, y:H*0.74, w:260, h:52}; }

  function handlePickTap(ev){
    const p = getCanvasPos(ev);
    const cards = getPickCards();
    for (let i=0;i<cards.length;i++){
      const c = cards[i];
      if (p.x>=c.x && p.x<=c.x+c.w && p.y>=c.y && p.y<=c.y+c.h){
        selected=i; updateHUD(); return;
      }
    }
    const b = getStartBtn();
    if (p.x>=b.x && p.x<=b.x+b.w && p.y>=b.y && p.y<=b.y+b.h){
      startRun();
    }
  }

  function drawPick(){
    drawSky(); drawCranes(); drawSea(); drawRoad(); drawBottomText();
    fillRect(0,0,W,H,"#000",0.18);

    const cards = getPickCards();
    for (let i=0;i<3;i++){
      const c = cards[i];
      fillRect(c.x, c.y, c.w, c.h, "#ffffff", 0.97);
      ctx.strokeStyle = (i===selected) ? "#1f6feb" : "#cbd5e1";
      ctx.lineWidth = (i===selected) ? 6 : 3;
      ctx.strokeRect(px(c.x+2), px(c.y+2), px(c.w-4), px(c.h-4));

      const ax = c.x + (c.w/2) - (player.w/2);
      const ay = c.y + 36;
      drawCharacter(ax, ay, CHAR[i].type);

      ctx.fillStyle="#0b0f14";
      ctx.textAlign="center";
      ctx.font="900 18px system-ui";
      ctx.fillText(CHAR[i].name, c.x + c.w/2, c.y + c.h - 22);
    }

    const b=getStartBtn();
    fillRect(b.x, b.y, b.w, b.h, "#1f6feb", 1);
    ctx.fillStyle="#ffffff";
    ctx.textAlign="center";
    ctx.font="900 18px system-ui";
    ctx.fillText("DÃ©marrer", W/2, b.y+34);
  }

  // ===== Win/Lose
  function drawWin(){
    drawSky(); drawCranes(); drawSea(); drawRoad();
    drawGaps(); drawBlocks(); drawHazards(); drawRunner();
    drawBottomText();

    fillRect(0,0,W,H,"#000",0.26);
    winT += 1/60;

    const cx = W/2;
    const cy = H*0.32;

    const g = ctx.createRadialGradient(cx, cy, 10, cx, cy, 280);
    g.addColorStop(0, "rgba(255,255,255,0.62)");
    g.addColorStop(0.35, "rgba(255,255,255,0.22)");
    g.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    const t = Math.min(1, winT / 1.25);
    const ease = 1 - Math.pow(1-t, 3);
    const scale = 0.18 + ease*1.05;
    const angle = (1-ease) * (Math.PI*7.0);
    const yPop = cy + (1-ease)*160;

    if (winT < 0.22) fillRect(0,0,W,H,"#ffffff", 0.14*(1-winT/0.22));

    ctx.save();
    ctx.translate(cx, yPop);
    ctx.rotate(angle);
    ctx.scale(scale, scale);
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.font="900 170px system-ui";
    ctx.fillStyle="#ffffff";
    ctx.fillText("ðŸ†", 0, 0);
    ctx.restore();

    ctx.textAlign="center";
    ctx.fillStyle="#ffffff";
    ctx.font="900 34px system-ui";
    ctx.fillText(`Bravo ${CHAR[selected].name} a gagnÃ© le trophÃ©e`, W/2, H*0.56);

    ctx.fillStyle="rgba(255,255,255,0.95)";
    ctx.font="800 16px system-ui";
    ctx.fillText(`Score: ${score}`, W/2, H*0.62);

    ctx.fillStyle="rgba(255,255,255,0.90)";
    ctx.font="700 13px system-ui";
    ctx.fillText("Tap / Espace: rejouer â€¢ C: changer de personnage", W/2, H*0.68);
  }

  function drawOver(){
    drawSky(); drawCranes(); drawSea(); drawRoad();
    drawGaps(); drawBlocks(); drawHazards(); drawRunner();
    drawBottomText();

    fillRect(0,0,W,H,"#000",0.38);
    ctx.textAlign="center";
    ctx.fillStyle="#ffffff";
    ctx.font="900 34px system-ui";
    ctx.fillText("ðŸ’¥ Perdu", W/2, H*0.44);
    ctx.font="800 16px system-ui";
    ctx.fillStyle="rgba(255,255,255,0.92)";
    ctx.fillText(`Score: ${score}`, W/2, H*0.51);
    ctx.font="700 13px system-ui";
    ctx.fillStyle="rgba(255,255,255,0.90)";
    ctx.fillText("Tap / Espace: recommencer â€¢ C: changer de personnage", W/2, H*0.58);
  }

  function drawRun(){
    drawSky(); drawCranes(); drawSea(); drawRoad();
    drawGaps(); drawBlocks(); drawHazards(); drawRunner();
    drawBottomText();
  }

  // ===== Main loop
  function loop(ts){
    const t = ts/1000;
    const dt = Math.min(0.033, (t - tPrev) || 0);
    tPrev = t;

    if (state===State.RUN) update(dt);

    if (state===State.PICK) drawPick();
    else if (state===State.RUN) drawRun();
    else if (state===State.OVER) drawOver();
    else if (state===State.WIN) drawWin();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>